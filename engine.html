<!DOCTYPE html>
<html>
<head>
    <title>Physics Sim</title>

    <link rel="stylesheet" type="text/css" href="css/styles.css" />

    <script type="text/javascript" src="js/three.min.js"></script>
    <script type="text/javascript" src="js/KeyboardState.js"></script>
    <script type="text/javascript" src="js/OrbitControls.js"></script>
    <script type="text/javascript" src="js/ThreeCSG.js"></script>
    <script type="text/javascript" src="js/dat.gui.min.js"></script>
    <script type="text/javascript" src="js/physi.js"></script>

    <script type="text/javascript">

'use strict';

Physijs.scripts.worker = 'js/physijs_worker.js';

var renderer, scene, camera, am_light, dir_light, loader, ground,
    barrelV, barrelH, box, target;
var GAME_RUNNING = true;
var keyboard = new KeyboardState();
var controls, orbCam;
var objectives = [
    "Ready to learn some Physics?\nIn addition to using the arrow keys to orient the cannon, you can input specific values in the control bar in the top-right corner of your screen. This will be useful for completing some of the objectives.<br> <br>Test purposes:<br> <br>Okay guys I did the physics for the first problem.<br>For the first target at position 60m, 80m, 0m set the following values:<br>Azimuth: 0.927rad<br>Altitude: 0.785rad<br>Velocity: 31.3 m/s<br> That should hit the target dead center.",
    "1. The target is located 60m east of the cannon, and 80m north.\nSet the altitude angle of the cannon to (PI/4 radians) in order to shoot that distance.\nYour task is to figure out the azimuth angle required to hit the target.<br>Instructions: <br>- Set the cannon's altitude to (PI/4 radians)<br>- Calculate the azimuth angle needed for the projectile to hit the target<br>- Orient the cannon with the controls and shoot to the target",
    "2. Think of the map as a grid, the cannon is at the position (30,50) and the target is at position (100, 70).<br>Set the altitude of the cannon to (PI/3 radians) to shoot the correct distance. <br>Figure out the azimuth angle needed to hit the target.",
    "3. Adjusting the altitude angle of the cannon to (2*PI/3 radians) will send the projectile flying <br>for (6 seconds) when the cannon launches the projectile at a velocity of (30 m/s). <br>Set the Azimuth to (0 radians).<br>At what distance should the target be set so that the projectile will hit it?<br>- Set the azimuth of the cannon to (0 radians), to aim at the target<br>- Calculate the position distance of the target <br>- Input the distance and shoot",
    "4. The target is located (X)m from the cannon in a direction of (Y) radians. Adjust the altitude angle of the cannon in order to shoot the projectile onto the target. (The cannon launches the projectile at a velocity of 30 m/s)<br><br>Instructions:<br>- Set the azimuth of the cannon to (Y) radians, to aim at the target<br>- Calculate the altitude angle needed for the projectile to hit the target, Click here to learn the physics",
    "5. The target is located (X)m horizontally from the cannon in a direction of (Y) radians, at a height of (20m). Adjust the altitude angle of the cannon in order to shoot the projectile onto the target. (The cannon launches the projectile at a velocity of 30 m/s)<br><br>Instructions:<br>- Set the azimuth of the cannon to (Y) radians, to aim at the target<br>- Calculate the altitude angle needed for the projectile to hit the target"
];

var instructions = [
    "Press Enter to see your first objective.",
    "Azimuth = The angle describing the direction of the cannon like north, south, or somewhere in between <br>Altitude = The angle describing how high the cannon is aiming, between vertical and horizontal <br><br>Math: <br> theta = atan(y/x) <br> y = north/south distance to the target <br> x = west/east distance to the target <br><br>*theta is the azimuth angle<br><br><br><br>Press Enter to show or hide this text",
    "Instructions:<br>- Set the cannon's altitude to (PI/4 radians)<br>- Calculate the azimuth angle needed for the projectile to hit the target<br><br> y = (y-target - y-cannon) <br> *y = north/south distance to the target<br> *y-target = y coordinate of the target ( __, 70 )<br> *y-cannon = y coordinate of the cannon ( __, 50 )<br><br> x = (x-target - x-cannon)<br> *x = west/east distance to the target<br> *x-target = x coordinate of the target ( 100, __ )<br> *x-cannon = x coordinate of the cannon ( 30, __ )<br><br> theta = atan(y/x)<br>*theta = azimuth angle",
    "Physics<br><br>v(x) = v * cos(theta)<br> *v(x) = horizontal component of the velocity of the projectile<br> *v = velocity of the projectile when launched<br> *theta = altitude angle of the cannon<br><br>d = v(x) * t<br> *d = distance from the cannon to the target<br> *v(x) = horizontal velocity of the projectile when launched<br> *t = time that passes from launch until collision",
    "Physics <br><br>Solve for t (theta will still be unknown)<br><br> s(x) = v * cos(theta) * t<br> *v = velocity of the projectile when launched<br> *theta = altitude angle of the cannon<br> *s(x) = horizontal distance from the cannon to the target <br> *t = time that passes from launch until collision<br><br><br>Substitute your answer for the t in this equation <br><br>-16.1 * t^2 + v * sin(theta) * t = 0<br> *-16.1 = 1/2 the acceleration due to gravity (m/s^2)",
    "Physics <br><br>(It is almost the same as the last problem, except the second equation is not equal to 0)<br>Solve for t (theta will still be unknown)<br><br> s(x) = v * cos(theta) * t<br> *v = velocity of the projectile when launched<br> *theta = altitude angle of the cannon<br> *s(x) = horizontal distance from the cannon to the target <br> *t = time that passes from launch until collision<br><br><br>Substitute your answer for the t in this equation <br><br>-16.1 * t^2 + v * sin(theta) * t = (20m)<br> *-16.1 = 1/2 the acceleration due to gravity (m/s^2)"
];

var level = 0;

function initScene() {
    showMessage(objectives[level] + '<br><br><br>' +  instructions[level]);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setClearColor(0xefd1b5); // reddish sky
    //renderer.setClearColor(0x9999ff); // blue
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('viewport').appendChild(renderer.domElement);

    scene = new Physijs.Scene;
    scene.setGravity(new THREE.Vector3(0, -9.8, 0));
    scene.fog = new THREE.FogExp2(0xefd1b5, 0.0025); // reddish sky
    //scene.fog = new THREE.FogExp2(0x9999ff, 0.001); // blue

    camera = new THREE.PerspectiveCamera(
        35, window.innerWidth / window.innerHeight, 1, 1000);
    // note: camera position is updated every frame
    camera.position.set(80, 60, 90);
    scene.add(camera);

    // for allowing camera rotation via mouse
    orbCam = new THREE.PerspectiveCamera(
        35, window.innerWidth / window.innerHeight, 1, 1000);
    orbCam.position.set(-80, 60, -90);
    controls = new THREE.OrbitControls(orbCam, renderer.domElement);

    // ambient light
    am_light = new THREE.AmbientLight(0x444444); // gray
    scene.add(am_light);

    // directional light
    dir_light = new THREE.DirectionalLight(0xFFFFFF);
    dir_light.position.set(200, 300, -50);
    dir_light.target.position.copy(scene.position);
    dir_light.castShadow = true;
    dir_light.shadowCameraLeft = -500;
    dir_light.shadowCameraTop = -500;
    dir_light.shadowCameraRight = 500;
    dir_light.shadowCameraBottom = 500;
    dir_light.shadowCameraNear = 80;
    dir_light.shadowCameraFar = 2000;
    dir_light.shadowBias = -.001;
    dir_light.shadowMapWidth = dir_light.shadowMapHeight = 2048;
    dir_light.shadowDarkness = .85;
    scene.add(dir_light);

    // Misc
    loader = new THREE.TextureLoader();
    renderer.shadowMap.enabled = true;

    // Ground
    var g_image = loader.load('images/' + (1 ? 'grass.png' : 'comeau.jpg'));
    var g_material = Physijs.createMaterial(
        new THREE.MeshLambertMaterial({ map: g_image }),
        .9, // high friction
        .2 // low restitution
    );
    g_material.map.wrapS = g_material.map.wrapT = THREE.RepeatWrapping;
    g_material.map.repeat.set(600, 600);

    ground = new Physijs.BoxMesh(
        new THREE.BoxGeometry(20000, 1, 20000),
        g_material,
        0, // mass
        { restitution: .2, friction: .8 }
    );
    ground.position.y = -.5; // top of surface is at 0
    ground.receiveShadow = true;
    scene.add(ground);

    // Call helpers
    makeCannon();
    makeProjectile();
    makeTarget();
    makeGUI();
    makeFloorCompass();
    requestAnimationFrame(render);
}

function makeProjectile() {
    var image = loader.load('images/' + (1 ? 'crate.jpg' : 'canada.jpg'));
    box = new Physijs.BoxMesh(
        new THREE.CubeGeometry(4, 4, 4),
        new THREE.MeshLambertMaterial({ map: image }),
        //new THREE.MeshLambertMaterial({ color: 0x888888 }),
        55, // mass
        { restitution: .9, friction: .1 }
    );
    box.position.y = 2.5; // prop it on top of the ground
    box.receiveShadow = true;
    box.castShadow = true;
    box.the_projectile = true;
    box.launchVelocity = 100;
    scene.add(box);
    dir_light.target = box; // allows us to always render shadows around box
}

function makeTarget() {
    var image = loader.load('images/target.jpeg');
    target = new Physijs.BoxMesh(
        new THREE.BoxGeometry(45, .1, 45),
        new THREE.MeshLambertMaterial({ map: image }),
        0,
        { restitution: 0, friction: 1 }
    );
    target.position.x = 80; //rand(90, 190);
    target.position.z = 60; //rand(90, 190);
    target.receiveShadow = true;
    target.castShadow = true;
    scene.add(target);

    target.addEventListener(
        'collision',
        function(other_obj, rel_vel, rel_rot, contact_normal) {
            if (other_obj.the_projectile) {
                level++;
                showMessage(
                    objectives[level]+'<br><br><br>'+instructions[level]);
                GAME_RUNNING = false;
            }
        }
    );
}

function makeFloorCompass() {
    if (1) { // the cool pirate compass
        var image = loader.load('images/pirateCompass.jpg');
        var geometry = new THREE.BoxGeometry(43.51, .1, 30);
        var rotation = -Math.PI/2;
    } else { // the normal boring compass
        var image = loader.load('images/basicCompass.jpg');
        var geometry = new THREE.BoxGeometry(30, .1, 35.8565);
        var rotation = 0;
    }

    var material = Physijs.createMaterial(
        new THREE.MeshLambertMaterial({ map: image }),
        0.5,
        0.5
    );
    var compass = new Physijs.BoxMesh(
        geometry,
        material,
        0,
        { restitution: 0, friction: 1 }
    );
    compass.position.x = -30;
    compass.position.z = -30;
    compass.rotation.y = rotation;
    compass.receiveShadow = true;
    scene.add(compass);
}

function makeCannon() {
    var track = new THREE.Mesh(
        new THREE.CylinderGeometry(10.1, 10.1, 8.2, 32),
        new THREE.MeshLambertMaterial({ color: 0x764F13 })
    );
    track.receiveShadow = true;
    track.castShadow = true;
    track.rotation.z = Math.PI/2;
    track.position.y = 4.1;

    var dome = new THREE.Mesh(
        new THREE.SphereGeometry(10, 32, 16),
        new THREE.MeshLambertMaterial({ color: 0x966F33 })
    );
    dome.position.y = 4;
    dome.receiveShadow = true;
    dome.castShadow = true;

    // barrel
    var smallCylinderGeom = new THREE.CylinderGeometry(3, 3, 15, 32, 4);
    var largeCylinderGeom = new THREE.CylinderGeometry(4, 4, 15, 32, 4);
    var smallCylinderBSP = new ThreeBSP(smallCylinderGeom);
    var largeCylinderBSP = new ThreeBSP(largeCylinderGeom);
    var intersectionBSP = largeCylinderBSP.subtract(smallCylinderBSP);
    var barrelMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 });
    var hollowCylinder = intersectionBSP.toMesh(barrelMaterial);
    hollowCylinder.position.y = 15;
    hollowCylinder.receiveShadow = true;
    hollowCylinder.castShadow = true;
    barrelV = new THREE.Object3D();
    barrelV.add(hollowCylinder);
    barrelV.position.y = 4; // keep rotation radius, but move to right place
    barrelH = new THREE.Object3D();
    barrelH.add(track);
    barrelH.add(barrelV);

    var base = new THREE.Mesh(
        new THREE.CylinderGeometry(10, 10, 8, 32),
        new THREE.MeshLambertMaterial({ color: 0x966F33 })
    );
    base.position.y = 4;
    base.receiveShadow = true;
    base.castShadow = true;

    base.add(barrelH);
    base.add(dome);
    scene.add(base);
}

function rand(min, max, interval) {
    if (typeof(interval) === 'undefined') interval = 1;
    var r = Math.floor(Math.random() * (max - min + interval) / interval);
    return r * interval + min;
}

function cameraChase(cam, mesh) {
    var cameraOffset = orbCam.position.clone().add(mesh.position);
    cam.position.set(cameraOffset.x, cameraOffset.y, cameraOffset.z);
    cam.lookAt(mesh.position);
}

function tossBox() {
    box.setAngularVelocity(
            new THREE.Vector3(rand(-7, 7), rand(-7, 7), rand(-7, 7)));
    box.setLinearVelocity(
            new THREE.Vector3(rand(-66, 66), rand(32, 123), rand(-66, 66)));
}

function shootBox() {
    box.position.set(0, 8, 0);
    box.setAngularVelocity(
            new THREE.Vector3(rand(-7, 7), rand(-7, 7), rand(-7, 7)));
    var speed = box.launchVelocity;
    var phi = barrelV.rotation.x;
    var theta = barrelH.rotation.y;
    var z = speed * Math.sin(phi) * Math.cos(theta); // math x | graphics z
    var x = speed * Math.sin(phi) * Math.sin(theta); // math y | graphics x
    var y = speed * Math.cos(phi); // math z | graphics y
    box.setLinearVelocity(new THREE.Vector3(x, y, z));
}

function updateShadows(light, mesh) {
    var relativeOffset = new THREE.Vector3(200, 300, -50);
    var newPos = relativeOffset.add(mesh.position);
    light.position.set(newPos.x, newPos.y, newPos.z);
}

function updateHUD() {
    var str = 'Use the arrow keys to position cannon and spacebar to ' +
        'shoot.<br>Press enter to show or hide the menu.';
    changeHTML('info', str);
    str = 'Longitude: ' + pad('    ', Math.round(box.position.x)) + 'm';
    changeHTML('longitude', str);
    str = '  Latitude: ' + pad('    ', Math.round(box.position.z)) + 'm';
    changeHTML('latitude', str);
    var alt = Math.round(box.position.y - box.geometry.parameters.height/2);
    str = '  Altitude: ' + pad('    ', alt) + 'm';
    changeHTML('altitude', str);
}

function changeHTML(id, str) {
    document.getElementById(id).innerHTML = str.replace(/ /g, '&nbsp;');
}

function handleUserInput() {
    keyboard.update();
    barrelH.__dirtyRotation = true;

    if (keyboard.pressed('up') && barrelV.rotation.x < Math.PI/2) {
        barrelV.rotation.x += 0.05;
    }
    if (keyboard.pressed('down') && barrelV.rotation.x > 0) {
        barrelV.rotation.x -= 0.05;
    }
    if (keyboard.pressed('left')) {
        barrelH.rotation.y += 0.05;
    }
    if (keyboard.pressed('right')) {
        barrelH.rotation.y -= 0.05;
    }

    if (keyboard.pressed('space')) {
        GAME_RUNNING = true;
        shootBox();
    }

    if (keyboard.down('enter')) {
        if (level == 0) {
            level = 1;
            showMessage(objectives[level]+'<br><br><br>'+instructions[level]);
        }
        else {
            toggleMessage();
        }
    }
}

function showMessage(str) {
    changeHTML('popupP', str);
    document.getElementById('popup').style.display = 'block';
    document.getElementById('popupP').style.display = 'block';
}

function toggleMessage() {
    if (document.getElementById('popup').style.display == 'none') {
        document.getElementById('popup').style.display = 'block';
        document.getElementById('popupP').style.display = 'block';
    } else {
        document.getElementById('popup').style.display = 'none';
        document.getElementById('popupP').style.display = 'none';
    }
}

function makeGUI() {
    var params = {
        velocity: 31.301,
        verticalBarrellAngle: 0.927,
        turretRotationAngle: 0.785,
    };

    var gui = new dat.GUI();
    var sceneGui = gui.addFolder('Details');

    sceneGui.add(params, 'velocity', 0.00, 200.0, 31.30)
        .name("Launch Velocity").onChange(function (value) {
            box.launchVelocity = value;
        });
    sceneGui.add(params, 'verticalBarrellAngle', 0.0, 2*Math.PI, 0.785)
        .name("Azimuth Angle").onChange(function (value) {
            barrelH.rotation.y = value;
            barrelH.__dirtyRotation = true;
        });
    sceneGui.add(params, 'turretRotationAngle', 0.0, Math.PI/2 ,0.927)
        .name("Altitude Angle").onChange(function (value) {
            barrelV.rotation.x = value;
            barrelV.__dirtyRotation = true;
        });
    gui.open();
}

function render() {
    handleUserInput();
    if (GAME_RUNNING) {
        box.__dirtyRotation = true;
        box.__dirtyPosition = true;
        scene.simulate();
        cameraChase(camera, box);
        updateShadows(dir_light, box);
        updateHUD();
    }
    controls.update();
    renderer.render(scene, camera);
    requestAnimationFrame(render);
}

function pad(pad, str, padRight) {
    if (typeof str === 'undefined') return pad;
    if (padRight) {
        return (str + pad).substring(0, pad.length);
    } else {
        return (pad + str).slice(-pad.length);
    }
}

window.onload = initScene;

    </script>
</head>

<body>
    <div id="viewport"></div>
    <div id="hud" style="position:absolute;left:10px;top:10px;background:rgba(0,0,0,0.3);">
        <div id="displays" style="position:relative;margin:3px;color:white;">
            <div id="info" style="top:0px"></div>
            <div id="longitude" style="top:10px"></div>
            <div id="latitude" style="top:20px"></div>
            <div id="altitude" style="top:30px"></div>
        </div>
    </div>
    <div id="popup" style="position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:800px;z-index:3;height:400px;color:white;background:rgba(0,0,0,0.7);">
        <div id="popupP" style="position:relative;margin:10px 10px 10px 10px;"></div>
    </div>
</body>
</html>
