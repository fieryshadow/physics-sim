<!DOCTYPE html>

<html>

<head>
    <title>Physics Sim</title>

    <link rel="stylesheet" type="text/css" href="css/styles.css" />

    <script type="text/javascript" src="js/three.min.js"></script>
    <script type="text/javascript" src="js/KeyboardState.js"></script>
    <script type="text/javascript" src="js/ThreeCSG.js"></script>
    <script type="text/javascript" src="js/dat.gui.min.js"></script>
    <script type="text/javascript" src="js/physi.js"></script>

    <script type="text/javascript">

'use strict';

Physijs.scripts.worker = 'js/physijs_worker.js';

var renderer, scene, camera, am_light, dir_light, loader, ground_material,
    ground, barrelV, barrelH, box, target;
var GAME_RUNNING = true;
var keyboard = new KeyboardState();

function initScene() {
    showMessage('Some sort of test objectives...');

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setClearColor(0xefd1b5); // reddish sky
    //renderer.setClearColor(0x9999ff); // blue
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('viewport').appendChild(renderer.domElement);

    scene = new Physijs.Scene;
    scene.setGravity(new THREE.Vector3(0, -32, 0));
    scene.fog = new THREE.FogExp2(0xefd1b5, 0.0025); // reddish sky
    //scene.fog = new THREE.FogExp2(0x9999ff, 0.001); // blue

    camera = new THREE.PerspectiveCamera(
        35, window.innerWidth / window.innerHeight, 1, 1000);
    // note: camera position is updated every frame
    camera.position.set(80, 60, 90);
    scene.add(camera);

    // ambient light
    am_light = new THREE.AmbientLight(0x444444); // gray
    scene.add(am_light);

    // directional light
    dir_light = new THREE.DirectionalLight(0xFFFFFF);
    dir_light.position.set(200, 300, -50);
    dir_light.target.position.copy(scene.position);
    dir_light.castShadow = true;
    dir_light.shadowCameraLeft = -500;
    dir_light.shadowCameraTop = -500;
    dir_light.shadowCameraRight = 500;
    dir_light.shadowCameraBottom = 500;
    dir_light.shadowCameraNear = 80;
    dir_light.shadowCameraFar = 2000;
    dir_light.shadowBias = -.001;
    dir_light.shadowMapWidth = dir_light.shadowMapHeight = 2048;
    dir_light.shadowDarkness = .85;
    scene.add(dir_light);

    // Loader
    loader = new THREE.TextureLoader();

    // Materials
    ground_material = Physijs.createMaterial(
        new THREE.MeshLambertMaterial({ map: loader.load('images/grass.png') }),
        .9, // high friction
        .2 // low restitution
    );
    ground_material.map.wrapS = ground_material.map.wrapT = THREE.RepeatWrapping;
    ground_material.map.repeat.set(600, 600);

    renderer.shadowMap.enabled = true;

    // Ground
    ground = new Physijs.BoxMesh(
        new THREE.BoxGeometry(20000, 1, 20000),
        ground_material,
        0, // mass
        { restitution: .2, friction: .8 }
    );
    ground.position.y = -.5; // top of surface is at 0
    ground.receiveShadow = true;
    scene.add(ground);

    makeCannon();

    // Projectile
    box = new Physijs.BoxMesh(
        new THREE.CubeGeometry(5, 5, 5),
        new THREE.MeshLambertMaterial({ color: 0x888888 }),
        55, // mass
        { restitution: .9, friction: .1 }
    );
    box.position.y = 2.5; // prop it on top of the ground
    box.receiveShadow = true;
    box.castShadow = true;
    box.the_projectile = true;
    box.launchVelocity = 10;
    scene.add(box);
    dir_light.target = box; // allows us to always render shadows around box

    target = new Physijs.BoxMesh(
        new THREE.BoxGeometry(15, .1, 15),
        new THREE.MeshLambertMaterial({ color: 0xFF2222 }),
        0,
        { restitution: 0, friction: 1 }
    );
    target.position.x = -rand(90, 190);
    target.position.z = -rand(90, 190);
    target.receiveShadow = true;
    target.castShadow = true;
    scene.add(target);
    target.addEventListener(
        'collision',
        function(other_obj, rel_vel, rel_rot, contact_normal) {
            if (other_obj.the_projectile) {
                showMessage('GAME OVER');
                GAME_RUNNING = false;
            }
        }
    );

    makeGUI();

    requestAnimationFrame(render);
}

function makeCannon() {
    var track = new THREE.Mesh(
        new THREE.CylinderGeometry(10.1, 10.1, 8.2, 32),
        new THREE.MeshLambertMaterial({ color: 0x764F13 })
    );
    track.receiveShadow = true;
    track.castShadow = true;
    track.rotation.z = Math.PI/2;
    track.position.y = 4.1;

    var dome = new THREE.Mesh(
        new THREE.SphereGeometry(10, 32, 16),
        new THREE.MeshLambertMaterial({ color: 0x966F33 })
    );
    dome.position.y = 4;
    dome.receiveShadow = true;
    dome.castShadow = true;

    // barrel
    var smallCylinderGeom = new THREE.CylinderGeometry(4, 4, 15, 32, 4);
    var largeCylinderGeom = new THREE.CylinderGeometry(5, 5, 15, 32, 4);
    var smallCylinderBSP = new ThreeBSP(smallCylinderGeom);
    var largeCylinderBSP = new ThreeBSP(largeCylinderGeom);
    var intersectionBSP = largeCylinderBSP.subtract(smallCylinderBSP);
    var barrelMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 });
    var hollowCylinder = intersectionBSP.toMesh( barrelMaterial );
    hollowCylinder.position.y = 15;
    hollowCylinder.receiveShadow = true;
    hollowCylinder.castShadow = true;
    barrelV = new THREE.Object3D();
    barrelV.add(hollowCylinder);
    barrelV.position.y = 4; // keep rotation radius - but moved to right place
    barrelH = new THREE.Object3D();
    barrelH.add(track);
    barrelH.add(barrelV);

    var base = new THREE.Mesh(
        new THREE.CylinderGeometry(10, 10, 8, 32),
        new THREE.MeshLambertMaterial({ color: 0x966F33 })
    );
    base.position.y = 4;
    base.receiveShadow = true;
    base.castShadow = true;
    base.add(barrelH);
    base.add(dome);
    scene.add(base);
}

function rand(min, max, interval) {
    if (typeof(interval) === 'undefined') interval = 1;
    var r = Math.floor(Math.random() * (max - min + interval) / interval);
    return r * interval + min;
}

function cameraChase(cam, mesh) {
    var relativeOffset = new THREE.Vector3(80, 60, 90);
    var cameraOffset = relativeOffset.add(mesh.position);
    cam.position.set(cameraOffset.x, cameraOffset.y, cameraOffset.z);
    cam.lookAt(mesh.position);
}

function tossBox() {
    box.setAngularVelocity(new THREE.Vector3(
                rand(-7, 7), rand(-7, 7), rand(-7, 7)));
    box.setLinearVelocity(new THREE.Vector3(
                rand(-66, 66), rand(32, 123), rand(-66, 66)));
}

function shootBox() {

    // // Projectile
    // box = new Physijs.BoxMesh(
    //     new THREE.CubeGeometry(5, 5, 5),
    //     new THREE.MeshLambertMaterial({ color: 0x888888 }),
    //     55, // mass
    //     { restitution: .9, friction: .1 }
    // );
    // box.position.y = 2.5; // prop it on top of the ground
    // box.receiveShadow = true;
    // box.castShadow = true;
    // scene.add(box);
    // dir_light.target = box; // allows us to always render shadows around box

    box.position.set(0, 8, 0);
    box.setAngularVelocity(new THREE.Vector3(
                rand(-7, 7), rand(-7, 7), rand(-7, 7)));
    var speed = box.launchVelocity;
    var phi = barrelV.rotation.x;
    var theta = barrelH.rotation.y;
    var x = speed * Math.sin(phi) * Math.sin(theta);
    var y = speed * Math.cos(phi); // up
    var z = speed * Math.sin(phi) * Math.cos(theta);
    box.setLinearVelocity(new THREE.Vector3(x, y, z));
}

function updateShadows(light, mesh) {
    var relativeOffset = new THREE.Vector3(200, 300, -50);
    var newPos = relativeOffset.add(mesh.position);
    light.position.set(newPos.x, newPos.y, newPos.z);
}

function updateHUD() {
    var str;
    str = 'Use the arrow keys to position cannon and spacebar to shoot.';
    changeHTML('info', str);
    str = 'Longitude: ' + pad('    ', Math.round(box.position.x)) + 'ft';
    changeHTML('longitude', str);
    str = '  Latitude: ' + pad('    ', Math.round(box.position.z)) + 'ft';
    changeHTML('latitude', str);
    var alt = Math.round(box.position.y - box.geometry.parameters.height/2);
    str = '  Altitude: ' + pad('    ', alt) + 'ft';
    changeHTML('altitude', str);
}

function changeHTML(id, str) {
    document.getElementById(id).innerHTML = str.replace(/ /g, '&nbsp;');
}

function handleUserInput() {
    keyboard.update();
    barrelH.__dirtyRotation = true;

    if (keyboard.pressed('up') && barrelV.rotation.x < Math.PI/2) {
        barrelV.rotation.x += 0.05;
    }
    if (keyboard.pressed('down') && barrelV.rotation.x > 0) {
        barrelV.rotation.x -= 0.05;
    }
    if (keyboard.pressed('left')) {
        barrelH.rotation.y += 0.05;
    }
    if (keyboard.pressed('right')) {
        barrelH.rotation.y -= 0.05;
    }

    if (keyboard.pressed('space')) {
        GAME_RUNNING = true;
        shootBox();
    }

    if (keyboard.down('enter')) {
        toggleMessage();
    }
}

function showMessage(str) {
    changeHTML('popupP', str);
    //console.log('here');
    //console.log(document.getElementById('popup').style.display)
    document.getElementById('popup').style.display = 'block';
    document.getElementById('popupP').style.display = 'block';
}

function toggleMessage() {
    if (document.getElementById('popup').style.display == 'none') {
        document.getElementById('popup').style.display = 'block';
        document.getElementById('popupP').style.display = 'block';
    } else {
        document.getElementById('popup').style.display = 'none';
        document.getElementById('popupP').style.display = 'none';
    }
}

function makeGUI(){

    var params = {
                    velocity: 50.0,
                    verticalBarrellAngle: 0.0,
                    turretRotationAngle: 0.0,
                };

    var gui = new dat.GUI();

    var sceneGui = gui.addFolder( 'Details' );

                sceneGui.add( params, 'velocity', 0.0, 200.0 ).name("Velocity").onChange(function (value) {
                    box.launchVelocity = value
                });
                sceneGui.add( params, 'verticalBarrellAngle', 0.0, 2*Math.PI).name("Altitude Angle")
                .onChange(function (value){
                    barrelH.rotation.y = value;
                    barrelH.__dirtyRotation = true; 
                });
                sceneGui.add( params, 'turretRotationAngle', 0.0, Math.PI/2 ).name("Altitude Angle")
                .onChange(function (value){
                    barrelV.rotation.x = value;
                    barrelV.__dirtyRotation = true; 
                });
                gui.open();

}

function render() {
    handleUserInput();
    if (GAME_RUNNING) {
        box.__dirtyRotation = true;
        box.__dirtyPosition = true;
        scene.simulate();
        cameraChase(camera, box);
        updateShadows(dir_light, box);
        updateHUD();
    }
    renderer.render(scene, camera);
    requestAnimationFrame(render);
}

function pad(pad, str, padRight) {
  if (typeof str === 'undefined') return pad;
  if (padRight) {
      return (str + pad).substring(0, pad.length);
  } else {
      return (pad + str).slice(-pad.length);
  }
}

window.onload = initScene;

    </script>
</head>

<body>
    <div id="viewport"></div>
    <div id="hud" style="position:absolute;left:10px;top:10px;background:rgba(0,0,0,0.3);">
        <div id="displays" style="position:relative;margin:3px;color:white;">
            <div id="info" style="top:0px"></div>
            <div id="longitude" style="top:10px"></div>
            <div id="latitude" style="top:20px"></div>
            <div id="altitude" style="top:30px"></div>
        </div>
    </div>
    <div id="popup" style="position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:800px;z-index:3;height:400px;color:white;background:rgba(0,0,0,0.7);">
        <div id="popupP" style="position:relative;margin:10px 10px 10px 10px;"></div>
    </div>
</body>
</html>
